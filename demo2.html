<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  symbol
  <!-- <script>
    const obj = {
      name: '小王',
      age: 19
    }
    //想要给一个对象添加属性和方法的时候,可能和原有对象的属性重名,我们希望有一个独一无二的值来替代属性名

    /* 
      Symbol类型
        - 代表独一无二的值
        - 不需要实例化 直接Symbol()即可创建一个独一无二的值
        - Symbol的参数只用来识别 没有任何作用
    */

    const sy1 = Symbol('sy1')//不强制,但是尽量写上变量名
    const sy2 = Symbol()
    console.log(sy1 === sy2)//false
    console.log(sy1)//Symbol()//红色
    console.log(typeof sy1)//symbol

    //把独一无二的值设置给对象上
    obj[sy1] = '哈哈'
    obj[sy2] = '呵呵'
    console.log(obj)
    
    //如果直接设置Symbol,除了getOwnPropertySymbols()没有任何方法可以获取
    obj[Symbol()] = '呜呜'

    //不能用new调用
    // console.log(new Symbol())//报错//Symbol is not a constructor
    console.log(String(Symbol()))//Symbol()
    console.log(Boolean(Symbol()))//true
    //console.log(Number(Symbol()))
    console.log(Object(Symbol()))////Symbol {Symbol()}

    //完美检测数据类型
    console.log(Object.prototype.toString.call(Symbol()).slice(8, -1).toLowerCase())//symbol

    //forIn 不能遍历symbol
    for (let i in obj) {
      console.log(i)//name age
    }

    //如果需要遍历对象中的Symbol属性,则直接使用Object.getOwnPropertySymbols(obj) 得到一个数组,数组中保存的是Symbol属性的key
    console.log(Object.getOwnPropertySymbols(obj))//[Symbol(sy1), Symbol(sy2), Symbol()]

    const symbolArray=Object.getOwnPropertySymbols(obj)
    symbolArray.forEach(function(i,j){
      console.log(obj[i])
    })


  </script> -->

  bigInt
  <!-- <script>
    //超过53个二进制位则计算进度不在准确
    console.log(2 ** 53)
    console.log(2 ** 53 + 1)
    console.log(2 ** 53 + 2)
    console.log(2 ** 53 + 3)
    console.log(2 ** 53 + 4)
    
    let a = 0.1
    let b = 0.2
    console.log(0.1 + 0.2)
    console.log((a * 10 + b * 10) / 10)

    //当数字大于2的1024次方的时候,则不再计算,直接返回无穷大
    console.log(2 ** 1024)
    console.log(2 ** 1023)
    console.log(2**1023 + 2** 1023)
    console.log(2**1023 + 2** 1022)

    /* 
      BigInt
        - 大整型:只能是整数
        - 定义的时候在整数后添加一个n即是bigInt类型
        - 只能和自身类型进行运算
    */
    const big1 = 1n
    console.log(big1)
    console.log(typeof big1)//bigInt
    // console.log(1n + 1)//不能计算大整型和其他类型
    console.log(1n + 1n)//2n

    // console.log(2n**1024n)
    // console.log(2n**1024000n)

    console.log(Number(1n))//1
    console.log(String(1n))//'1'
    console.log(Boolean(1n))//true

    console.log(1n==1)//true
    console.log(1n===1)//false

    console.log(new BigInt())//BigInt is not a constructor

  箭头函数
  <!-- <script>
    // 函数没有参数并且函数体只有一句话的时候
    function fn1(){
      // return 'hello'
      console.log(1)
    }

    const fn11=()=>'hello'
    console.log(fn11)
    const fn12=()=>console.log(1)
    fn12()

    // 函数有参数,并且函数内容不仅仅是一句话
    function fn2(a){
      a++
      return a
    }
    const fn21=a=>{
      a++
      return a
    }
    console.log(fn21(2))

    const fn22=(a,b)=>{
      return a+b
    }
    console.log(fn22(1,2))

    

  </script> -->

  箭头函数基本概念和用法
  <!-- <script>
    /* //函数没有参数 并且函数体只有一句话的时候
    function fn1() {
      // return 'hello'
      console.log(1)
    }
    const fn11 = () => 'hello'
    const fn12 = () => console.log(1)
    console.log(fn11())//'hello'
    fn12()//1 */

    // 函数没有参数 并且函数体内容不仅仅是一句话
    function fn2(a, b) {
      a++
      return a
    }
    const fn21 = a => {
      a++
      return a
    }
    const fn22 = (a, b) => {
      a++
      return a + b
    }
    console.log(fn21(2))//3
    console.log(fn22(2, 1))//4

  </script> -->

  箭头函数书写练习(改以前的)
  <!-- <script>
    // reduce求数组的最大值
    /* const arr = [1, 3, 5, 7, 9, 2, 4, 5, 3, 1]
    const re = arr.reduce((p, c) => p > c ? p : c)
    console.log(re) */

    // 计算字符串中每一个值出现的次数, 用对象来表示
    /* const str = "abcdaedfbcdba"
    const re = [...str].reduce((p, c) => {
      p[c] ? p[c]++ : p[c] = 1
      return p
    }, {})
    console.log(re) */

    // 数组去重
    /* const arr = [1, 3, 3, 2, 1, 1, 4, 5, 3, 4, 7, 6, 5, 7]
    const re = arr.reduce((p, c) => p.includes(c) ? p : [...p, c], [])
    console.log(re) */


    // 数组扁平化
    /* const arr = [[1, 2], [3, 4], [5, [6]]]
    function flat(arr) {
      // if (!Array.isArray(arr)) {
      //     return arr;
      // }
      // return arr.reduce(function (p, c) {
      //     return p.concat(flat(c))
      // }, []);
      return !Array.isArray(arr) ? arr : arr.reduce((p, c) => p.concat(flat(c)), []);
    }
    console.log(flat(arr)) */

    //数组的单向对比
    /* const arr1 = [1, 2, 3, 4, 5, 6, 7]
    const arr2 = [2, 3, 5, 6]


    function fn(arr1 = [], arr2 = []) {
      const re = arr1.reduce((p, c) => {
        arr2.includes(c) || p.push(c)
        return p
      }, [])
      console.log(re)
    }
    fn(arr1, arr2) */

  </script> -->

  箭头函数知识点
  <!-- <script>
    /* 
      箭头函数
        - 关于this 箭头函数没有自己的this,箭头函数内部的this并不是调用的时候指向对象,而是定义的时候指向外层this 
        - 箭头函数不能作为构造函数
        - 箭头函数没有arguments,因为可以用...rest
    */
    /* const obj = {
      name: '老王',
      do() {
        console.log(this)//obj
        setTimeout(() => {
          console.log(this)//obj
        })
      },
      do2: () => {
        console.log(this)//window
        setTimeout(() => {
          console.log(this)//window
        })
      }
    }
    obj.do()//obj obj
    obj.do2()//window window */


    /* const fn=(name)=>{
      this.name=name
    }
    console.log(new fn('老王'))//fn is not a constructor */

    /* const fn=(...rest)=>{
      console.log(rest)
      console.log(arguments)//arguments is not defined
    }
    fn(1,2,3) */


  </script> -->

  新增数据结构Set
  <!-- <script>
    // Set:说白了就是数组去重,重复的值是添加不进去的
    /*
      Set类型:成员唯一
        size 返回Set的长度(类似数组length)
        add  添加某个值,返回Set结构本身
        delete 删除某个值,返回一个布尔值,表示删除是否成功
        has 返回一个布尔值,表示该值是否为Set的成员
        clear 清楚所有成员,没有返回值
        forEach() 使用回调函数遍历每个成员
    */
    /* const set1 = new Set([1, 2, 1, 2, 3, 3, 2, 3, 4, 5, 4, 3])
    console.log(set1)//{1,2,3,4,5}
    console.log([...set1])//[1,2,3,4,5] */
    // ---------------------------------
    /* console.log(set1.size)
    console.log(set1.add("a"))
    console.log(set1.delete(3)) //里边跟的是值 不是下标 返回值是删除成功或失败
    console.log(set1.has(3)) //false
    set1.forEach((item, index) => {
      console.log(item)//1 2 4 5 a
    })
    console.log(set1.clear())//undefined
    console.log(set1)//Set(0) {} */
    // --------------------------------
  </script> -->

  Set的应用
  <!-- <script>
    // 数组去重
    const arr = [1, 2, 1, 2, 3, 3, 2, 3, 4, 5, 4, 3]
    console.log([...new Set(arr)])//[1, 2, 3, 4, 5]

    // 去除字符串里面的重复字符串
    const str = 'abcdcdsgerer';
    console.log([...new Set([...str])].join(''))//abcdsger
  </script> -->

  新增数据结构 Map
  <!-- <script>
    /* Map :
      - key-value是有序的
      - key可以是任意类型

    size 属性返回Map结构的成员总数
    set 方法设置键名key对应的键值为value,然后返回整个Map结构.如果key已经有值,则键值会被更新,否则新生成该键. set 方法返回的是当前Map对象,因此可以采用链式写法
    get 方法读取key对应的键值,如果找不到key,返回undefined.
    has方法返回一个布尔值,表示某个键是否在当前Map对象中
    delete 方法删除某个键,返回true.如果删除失败,返回false
    clear方法清除所有成员,没有返回值
    forEach():遍历Map的所有成员 */

    const fn = function () { }
    let mp1 = new Map([
      ['name', '老王'],
      ['age', 18],
      [{
        a: 'b'
      }, 18],
      [NaN, 18],
      [undefined, 18],
      [null, 18],
      [fn, 18]
    ])
    console.log(mp1)
    console.log(mp1.size)//7
    console.log(mp1.get(null))//18
    console.log(mp1.set("foo", "foo1"))
    console.log(mp1.has(true))//false
    console.log(mp1.delete(true))//fasle
    console.log(mp1)

    mp1.forEach((value, key) => {
      console.log(key, value)//都可以拿到,且键名并没有转换字符串
    })

    console.log(mp1.clear())//undefined
    console.log(mp1)//Map(0) {}
  </script> -->

</body>

</html>