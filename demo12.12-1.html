<!DOCTYPE html>
<html lang="">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<style>
</style>

<body>
  <input type="text" id="input">
  <button id="btn1">牛逼的按钮1</button>
  <button id="btn2">无敌的按钮2</button>
  <ul class="ul1">
    <li>你好!<a href="#">删除</a></li>
  </ul>
  <div class="outer">
    <div class="inner">哈哈
      <a href="###" id="aa" class="shuxin haha" data-ssh="datassh" study='js'> 今天天气好</a>
    </div>
  </div>
  <div class="shuxinlianxi">
    <style>
      #ul1>li {
        background-color: darkcyan;
        cursor: pointer;
      }
    </style>
    <ul id="ul1" style="width: 400px; background-color: bisque;list-style: none;">
      <li>这是li1</li>
      <li>这是li2</li>
      <li>这是li3</li>
      <li>这是li4</li>
      <li>这是li5</li>
    </ul>
  </div>
  <style>
    * {
      margin: 0;
      padding: 0;
    }

    .tab {
      width: 500px;
      border: 1px solid black;
      margin: 20px;
    }

    .tab>.title {
      display: flex;
    }

    .tab>.title>h2 {
      width: 198px;
      border: 1px solid black;
      height: 40px;
      line-height: 40px;
      text-align: center;
      font-size: 26px;
    }

    .title>h2.active {
      background-color: salmon;
      color: snow;
    }

    .content {
      height: 300px;
      overflow: auto;
    }
    .content>section{
      height: 300px;
      text-align: center;
      line-height: 300px;
      font-size: 40px;
    }
    .content>section:nth-child(1){
      background-color: steelblue;
    }
    .content>section:nth-child(2){
      background-color: forestgreen;
    }
    .content>section:nth-child(3){
      background-color: rebeccapurple;
    }
    .content>section.show{
      display: block;
    }
  </style>
  <div class="outer">
    <div class="tab">
      <!-- 标题 -->
      <header class="title">
        <h2 class="active">标题1</h2>
        <h2>标题2</h2>
        <h2>标题3</h2>
      </header>
      <!-- 内容 -->
      <div class="content">
        <section class="show">内容1</section>
        <section>内容2</section>
        <section>内容3</section>
      </div>
    </div>
  </div>
  <!-- ```鱼塘管理系统reload -->
  <!-- <script>
    var btn1=document.getElementById('btn1')//获取按钮1
    var input=document.getElementById('input')//获取输入框
    var ul1=document.querySelector('.ul1')//获取ul1
    btn1.onclick=function(){//绑定事件添加元素
      var newli=document.createElement('li')//创建新dom节点名字叫newli
      newli.innerHTML=input.value+'<a href="#">删除</a>'//添加newli的内容
      ul1.appendChild(newli)//将newli放进ul1
      var as=document.querySelectorAll('a')//获取所有a
      as.forEach(function(item,index){//遍历所有a
        as[index].onclick=function(){//为a[index]添加单击事件
          item.parentNode.parentNode.removeChild(item.parentNode)//移除该行
        }
      })
    }
  </script> -->
  <!-- ```innerHTML\innerText\textContent -->
  <!-- ```outerHtml\outerText -->
  <!-- <script>
    /* outerHTML:
      - 获取的时候 把当前元素也获取到了，并不是只获取内部的内容
      - 设置的时候，直接把当前元素替换掉了
      - 获取的时候 标签被当做字符串获取到了
      - 设置的时候 字符串中的标签直接被解析
    outerText:
      - 获取的时候，其实和innerText没区别  因为都是拿元素的文本内容
      - 设置的时候，直接替换当前外部元素 
      - 获取的时候，只获取元素中的文本节点内容
      - 设置的时候，字符串中的标签不会被解析 
      获取和设置元素的内容：
    innerHTML:
      - 获取的时候 标签被当做字符串获取到了
      - 设置的时候 字符串中的标签直接被解析
    innerText:
      - 获取的时候，只获取元素中的文本节点内容
      - 设置的时候，字符串中的标签不会被解析
    textContent：
      - 获取的时候，只获取元素中的文本节点内容
      - 设置的时候，字符串中的标签不会被解析
    */
    // textContent和innerText的区别：
    //   - textContent可以获取空白文本
    //   - textContent兼容性差 ie9及以上
    var btn1=document.getElementById('btn1')
    var btn2=document.getElementById('btn2')
    var inner=document.querySelector('.inner')
    btn1.onclick=function(){
      console.log(inner.innerHTML);//包含标签,空白
      console.log(inner.innerText);//只获取文本节点
      console.log(inner.textContent);//只获取文本节点//可获取空白//兼容性差(ie9及以上)
      console.log(inner.outerHTML);//在innerHtml的基础上,包含当前元素自身
      console.log(inner.outerText);//和innerText类似,结果相同
    }
    btn2.onclick=function(){
      // inner.innerHTML='<h1>你是笨蛋</h1>'//解析标签
      // inner.innerText='<h1>你是笨蛋</h1>'//不解析标签
      // inner.textContent='<h1>你是笨蛋</h1>'//不解析标签
      inner.outerHTML='<h1>你是笨蛋</h1>'//解析标签&替换当前元素
      inner.outerText='<h1>你是笨蛋</h1>'//不解析标签&替换当前元素
    }
  </script> -->
  <!-- ```读取属性 -->
  <!-- <script>
    /* 读取属性值：
      ele.getAttribute(属性名)
      # 自有属性
        - 可以直接通过 元素对象.属性名 获取到
        - 如果某些自有属性和js的关键字冲突了，那么就会把当前自有属性获取的方法修改比如class属性获取的时候 可以通过className获取
      # 自定义属性
        - 不能直接通过 元素对象.属性名 获取到，因为他在当前元素的自有属性上没有找到该属性，则会把当前元素对象当作一个js对象，去获取他的属性了
        - 自定义属性要通过getAttribute去找，才能去元素的属性上找当前自有属性 */

    /* 设置属性值：
      # 自有属性
        - 直接设置即可
      # 自定义属性
      setAttribute(key, value) */
      
    /* 删除属性值：
    # 自有属性
      - 直接设置为空字符串
      - 表单的一些属性 直接设置为false
    # 自定义属性
    removeAttribute */
    var aa=document.getElementById('aa')
    var btn1=document.getElementById('btn1')
    var btn2=document.getElementById('btn2')
    btn1.onclick=function(){
      console.log(aa.id);//aa
      console.log(aa.class);//undefined
      console.log(aa.clssName);//undefined
      console.log(aa.study);//undefined
      console.log(aa.getAttribute('study'));//js
    }
    btn2.onclick=function(){
      aa.id='newId'//成功
      aa.className='newClassName'//成功
      aa.setAttribute('study','newStudy')//成功
      aa.setAttribute('mySetAttribute','成了没')//成功//可以设置也可以修改
      aa.removeAttribute('study')//成功
    }
  </script> -->
  <!-- ```属性练习 -->
  <!-- <script>
    var btn1=document.getElementById('btn1')
    var ul1=document.getElementById('ul1')
    var lis=document.querySelectorAll('#ul1>li')
    //==>为所有li添加点击事件
    /* lis.forEach(function(i,j){
        i.onclick=function(){
          i.setAttribute('click','true')//设置一个自定义属性作为标记
        }
      }) */
    //==>点击按钮1,筛选标记,变色,去除标记
    /* btn1.onclick=function(){
      lis.forEach(function(i,j){
        if(i.getAttribute('click')){//如果有这个属性,就是true,如果没有,null转换结果为false
          i.style.background='red'//变色
          // 去掉标记
          i.removeAttribute('click')
          
        }
      })
    } */
    //==>点击按钮2去掉颜色
    /* btn2.onclick=function(){
      lis.forEach(function(i,j){
        i.removeAttribute('style')//直接取出加上去的背景颜色
      })
    } */
    //
  </script> -->
  <!-- ```h5自定义属性 -->
  <!-- <script>
    /* h5规定：
      如果是自定义属性 请添加data-*前缀
      h5给每一个元素提供了一个dataset属性，是一个对象，保存的是当前元素所有的自定义属性
      只要对dataset这个对象操作属性 就是给当前元素操作自定义属性
    `设置h5自定义属性
        使用 ele.dataset.key = value
    `获取自定义属性
        使用 ele.dataset.key
    `删除自定义属性
        使用 delete ele.dataset.key */

    var aa=document.getElementById('aa')
    var btn1=document.getElementById('btn1')
    btn1.onclick=function(){
      console.log(aa.dataset.ssh);//查看
      aa.dataset.ssh='nihoa'//设置
      console.log(aa.dataset.ssh);//查看
      console.log(aa.dataset);//查看dataset对象
      delete aa.dataset.ssh//删除ssh属性
      console.log(aa.dataset);//查看dataset对象
    }
  </script> -->
  <!-- ```属性练习h5写法 -->
  <!-- <script>
    var ul1=document.getElementById('ul1')
    var lis=document.querySelectorAll('#ul1>li')
    var btn1=document.getElementById('btn1')
    var btn2=document.getElementById('btn2')
    lis.forEach(function(i,j){
      i.onclick=function(){
        i.dataset.click='true'
      }
    })
    btn1.onclick=function(){
      lis.forEach(function(i,j){
        if(i.dataset.click){
          i.style.background='red'//设置颜色
          delete i.dataset.click//这里删除click属性即可
        }
      })
    }
    btn2.onclick=function(){
      lis.forEach(function(i,j){
        i.removeAttribute('style')
      })
    }
  </script> -->
  <!-- ```文档碎片节点 -->
  <!-- <script>
    /* 重排和重绘是DOM编程中耗能的主要原因之一:
      -重排（回流）：当render tree中的一部分或者是全部，因为元素的尺寸、布局、隐藏等等改变引起页面的重新渲染，这个过程称作为重排
      -重绘：当render tree（渲染树）中更新的属性只会影响元素的外观、风格，不会影响元素的布局的时候，浏览器需要重新绘制当前元素的样式，被称作为重绘。
      -重绘不会引起重排，但重排一定会引起重绘，一个元素的重排通常会带来一系列的反应，甚至触发整个文档的重排和重绘，性能代价是高昂的 */
    var ul1=document.getElementById('ul1')
    var btn1=document.getElementById('btn1')
    btn1.onclick=function(){
      var frag=document.createDocumentFragment()//创建一个文档碎片节点
      for(var i=0;i<100;i++){//创建100次li文档节点,并且都放进去frag碎片节点
        var newLi=document.createElement('li')
        newLi.innerHTML='你好'
        frag.appendChild(newLi)//将创建好的文档节点放进frag碎片节点
      }
      console.log(frag);//打印frag碎片节点
      ul1.appendChild(frag)//将碎片节点frag放进ul(不会每次添加都引起重排,100次添加只会重排一次)
    }
  </script> -->
  <!-- ```tab切换动画版 -->
  <script>
    var h2s=document.querySelectorAll('.title h2')//获取所有h2标题
    var sections=document.querySelectorAll('.content section')//获取内容区下的section
    var content=document.querySelector('.content')//获取内容区域
    var tabTimer=null//设置定时器名称
    h2s.forEach(function(i,j){//遍历h2s

      i.onclick=function(){//为所有h2添加点击事件
        clearInterval(tabTimer)//清掉计时器
        h2s.forEach(function(i,j){//当点击标题,再次遍历h2,移除所有active
          i.classList.remove('active')
        })
        this.classList.add('active')//this是当前点击的元素i

        //==>定义一个通用动画
        //开始位置(当前滚动条位置)
        var startLocation=content.scrollTop
        //结束位置(当前元素的index乘以任意section的offsetHeight(都是300),就是要移动的像素
        var endLocation=j*sections[1].offsetHeight
        //开始步数
        var startStep=0
        var endStep=40//假设走40步
        var everyStep=(endLocation-startLocation)/(endStep-startStep)//每一步需要走的距离==>每一步需要走结束位置减去开始位置除以需要的步数
        tabTimer=setInterval(function(){
          startLocation+=everyStep//每次让开始位置加上每步走的距离
          // 步数增加
          startStep++
          // 判断是否到终点
          if(startStep>=endStep){
            clearInterval(tabTimer)
          }
          // 为每次运动赋值
          content.scrollTop=startLocation

          /* 
          //初始位置累加错误方法(如果直接拿scrollTop运算,则会忽略小数)
          oCon.scrollTop += everyStep;
          console.log(everyStep)
          console.log(oCon.scrollTop) */

        },1)
      }
    })

  </script>
</body>


</html>