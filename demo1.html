<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <!-- 算法都有时间复杂度和空间复杂度,需要用到微积分之类的东西(9:30左右开始讲 -->
  数据结构书-高数
  ! a && b===a||b
  <!-- <script>

  </script> -->
  1 冒泡排序解构赋值版本(不需要中间值)
  <!-- <script>
    let arr = [2, 1, 3, 0, 6, 1, 4, 5, 3, 2, 8, 2]
    for (let i = 0; i < arr.length; i++) {
      for (let j = 0; j < arr.length - i; j++) {
        if (arr[j] > arr[j + 1]) {
          [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]]
        }
      }
    }
    console.log(arr)
  </script> -->

  2 万物皆可reduce
  <!-- <script>
    //-----------------------------------------
    //reduce求数组的最大值
    /* const arr=[1,3,5,7,9,2,4,5,3,1]
    const re=arr.reduce(function(p,c){//prev current
      return p>c?p:c
    })
    console.log(re) */
    //-----------------------------------------
    //计算字符串中每一个值出现的次数,用对象来表示
    /* const str='abcdadefbcdba';
    const re=[...str].reduce(function(p,c){
      p[c]?p[c]++:p[c]=1
      return p
    },{})
    console.log(re) */
    //-----------------------------------------
    //数组去重
    /* const arr=[1,3,3,2,1,1,4,5,3,4,7,6,5,7]
    const re=arr.reduce(function(p,c){
      if(p.includes(c)){
        return p
      }
      // p.push(c)//返回长度
      // return p.concat(c)//返回新数组的引用
      return [...p,c]//直接return解构赋值的上一个数组加上这次满足条件的c
    },[])
    console.log(re) */
    //-----------------------------------------
    //数组扁平化
    /* const arr = [[1, 2], [3, 4], [5, [6]]]

    function flat(arr) {
      if (!Array.isArray(arr)) {//如果不是数组返回该arr
        return arr
      }
      return arr.reduce(function (p, c) {
        return p.concat(flat(c))
      }, [])
    }
    console.log(flat(arr))

    // const re=arr.reduce(function(p,c){
    //   return [...p,...c]
    // },[])
    // console.log(re)*/
    //-----------------------------------------
    // 数组的单向对比版
    // 对比arr1和arr2,如果arr1里面有arr2没有的元素,放入空数组
    /* const arr1 = [1, 2, 3, 4, 5, 6, 7];
    const arr2 = [2, 3, 5, 6];

    function fn(arr1 = [], arr2 = []) {
      const re = arr1.reduce(function (p, c) {
        arr2.includes(c) || p.push(c) //当arr2里面没有arr1的该元素, 将改元素放入空数组p
        return p
      }, [])
      return re
    }
    console.log(fn(arr1, arr2)) */
  </script> -->

  3 对象扩展,简写
  <!-- <script>
    const name = '老王', age = 15, sex = '男'
    // 对象普通写法
    const obj = {
      name: name,
      age: age,
      sex: sex,
      hobby: '吃',
      do: function () {
        console.log(123)
      }
    }
    console.log(obj)

    // 对象的简写
    // 1.当key和value(一定是一个变量)一样,可以直接简写一个key
    // 2.方法可以直接省略冒号和function 进行简写
    const obj2 = {
      name,
      age,
      sex,
      hobby: '吃',
      do() {
        console.log(123)
      }
    }
    console.log(obj2)
  </script> -->

  4 属性名和表达式
  <!-- <script>
    /* 
      对象的key一定最后会解析成字符串
        - 当给一个'已有对象'添加属性的时候,可以使用.操作符和[]操作符
          - []操作符是通用的,无论key是字符串还是变量都可以书写
          - .操作符只能key是字符串的时候
          - []操作符使用场景:1.key是变量 2.key是命名不规范的字符串 

        - 创建对象的时候,书写的key都是字符串,不会理解为一个变量(ES5)
          - ES6提供了一个属性名表达式,当创建对象的时候,吧key用[]括起来,这个key就可以书写变量和字符串了
    */
    const key1 = name
    const key2 = sex
    const key3 = [1, 2]
    const obj = {
      //  key2:'男'//解析出来是key2
      [key2]: '男',
      ['hobby']: 'eat',
      [key3]: '啊哈'
    }
    obj[key1] = '老王'
  </script> -->

  5 Object的静态方法
  <!-- <script>
    /* 
      Object.is():
        判断2个对象是否相等(其实就是全等),一个区别就是修复了NaN不等于NaN的问题
    */
    /* console.log(object.is(1, 1))
    console.log(object.is('a', 'a'))
    console.log(NaN === NaN)
    console.log(object.is(NaN, NaN))
    console.log(object.is({ name: '奥威' }, { name: '奥威' })) */

    /* 
      Object.assing(obj1,obj2,obj3)合并对象把第二个参数之后的对象合并到第一个对象上,并返回第一个对象的地址
    */
    /* const obj1={name:'老王'}
    const obj2={sex:'男'}
    const obj3={age:12}

    // const re=Object.assign(obj1,obj2,obj3)
    // console.log(re)
    // console.log(obj1)
    // console.log(re===obj1)//其实就是把2和3的内容放到嗯呢1,改变了1且返回1的引用值

    const re2=Object.assign({},obj1)
    console.log(re2)
    console.log(obj1)
    console.log(re2===obj1) */

  </script> -->

  5.5 手写判断对象是否相等的函数
  <script>
    //练习：判断两个对象是否相等
    var deepEqual = function (x, y) {
      // 判断两个对象是否指向同一内存时（或者两个基本类型），直接返回true
      if (x === y) {
        return true;
      }
      //判断两个对象都是对象类型并且不是null的时候
      else if ((typeof x == "object" && x != null) && (typeof y == "object" && y != null)) {
        //首先判断两个对象的长度是否相等（通过keys获取键名的迭代器对象）
        if (Object.keys(x).length != Object.keys(y).length) {
          //如果长度不相等 则直接返回false
          return false;
        }
        //遍历其中一个对象
        for (var prop in x) {
          //判断另一个对象是否在这个对象中出现
          if (y.hasOwnProperty(prop)) {
            //比较两个对象相同属性的值是否相等，如果不等则返回false
            if (!deepEqual(x[prop], y[prop])) {
              return false;
            }
          } else {
            //如果一个对象不在这个对象中出现，则直接返回false
            return false;
          }
        }
        //如果以上情况都不返回false，则返回true
        return true;
      } else {
        //当两个值既不是对象，也不相等的时候，则直接返回false
        return false;
      }
    }

    const obj1 = { name: '老王', sex: '男', do() { console.log(1) } }
    const obj2 = { name: '老王', sex: '男', do() { console.log(1) } }

    console.log(deepEqual(obj1, obj2))//false
  </script>

  6 函数参数和rest参数
  <!-- <script>
    //ES5给默认值
    function fn(a, b) {
      //如果用户没有传递b,则b默认为0
      // b=b?b:0
      return a + (b || 0)
    }
    console.log(fn(1))

    // ES6给默认值
    function fn2(a, b = 0) {
      return a + b
    }
    console.log(fn2(1))
    console.log(fn2(1,3))

    //rest参数 用来替代arguments 直接返回一个数组,只能写在末尾
    function add(a,...rest){
      console.log(a)
      console.log(rest)
    }
    add(1,2,3,4,5)

  </script> -->

  7 修改手写call(修改...rest,添加Symbol()作为键名)
  <script>
    Function.prototype.myCall = function (context, ...rest) {
      var type = typeof context;
      if (context === null || context === undefined) {
        context = window;
      }
      switch (type) {
        case "number":
          context = new Number(context);
          break;
        case "boolean":
          context = new Boolean(context);
          break;
        case "string":
          context = new String(context);
          break;
      }

      var key = Symbol('key');
      context[key] = this;
      var result = context[key](...rest);
      delete context[key];
      return result;
    }

    //-----------------------------------
    var obj = {
      name: "laowang",
      fn: function () {
        console.log("hello")
      }
    }
    function fn1(a, b) {
      console.log(this, a + b)
      return "123";
    }
    console.log(fn1.call(obj, 1, 2));
    fn1.call(null, 1, 2);
    fn1.call(undefined, 1, 2);
    fn1.call(1, 1, 2);
    fn1.call("str", 1, 2);
    fn1.call(true, 1, 2);
    
    fn1.myCall(obj, 1, 2);
    fn1.myCall(null, 1, 2);
    fn1.myCall(undefined, 1, 2);
    fn1.myCall(1, 1, 2);
    fn1.myCall("str", 1, 2);
    fn1.myCall(true, 1, 2);
  </script>
</body>

</html>