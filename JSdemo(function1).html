<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <!-- <script>
    //==>函数的打印方式2种
    function oyx(){
    var a=1
    var b=2
    var c=a+b
    }
    console.log(oyx)//这是函数的constructor
    console.dir(oyx)//这是函数的对象
  </script> -->
  <!-- <script>
    //==>定义一个函数实现数组每个元素+1
    function ab(arr){
      var newArr=[]
      for(let i=0;i<arr.length;i++){
        newArr[newArr.length]=arr[i]+10
      }
      return   newArr
    }
    var arr=[1,2,3,4,5]
    console.log(ab(arr))
  </script> -->
  <!-- <script>
    //==>打印0-n的质数
    function zi(n){
      for(let i=1;i<=n;i++){
        var flag=0
        for(let j=0;j<=i/2;j++){//这里/2提高性能
          if(i%j===0){
          flag++;
        }
        }
        if(flag===1&&i!=1){//因为上面除以2了,所以只有1和本身的本身 无法渠道,即,只有1的时候和值非1的时候打印即可
          console.log(i);
        }
      }
    }
    zi(100)

  </script> -->
  <!-- <script>
    //==>数组排序
    function paixu(arr) {
      for (let i = 0; i < arr.length; i++) {
        for (let j = 0; j < arr.length; j++) {
          if(arr[j]>arr[j+1]){
            var tmp=arr[j+1]
            arr[j+1]=arr[j]
            arr[j]=tmp
          }
        }
      }
      console.log(arr);
    }
    paixu([1, 3, 5, 2, 1, 4, 2, 6, 8, 453, 346, 3, 435, 3, 34, 5, 234, 2, 72, 62])
  </script> -->
  <!-- <script>
    //==>数组翻转
    var arr=[5,4,3,2,1,"a","b","c",1]
    console.log(arr);
    function fanzhuan(arr){
      for(let i=0;i<arr.length/2;i++){
        var tmp=arr[i]
        arr[i]=arr[arr.length-i-1]
        arr[arr.length-i-1]=tmp
      }
      console.log(arr);
    }
    fanzhuan(arr)
    
  </script> -->
  <!-- <script>
    //==>数组去重
    var arr = [1, 1, 2, 2, 2, 3, 4, 4, 4, 5, 4, 4]
    function quchon() {
      var na = [arr[0]]
      for (let i = 0; i < arr.length; i++) {
        var flag = true//这个同理,也不能放在下面的for里面,因为放在里面每次运行判断na的内元素,都会重新编程true
        for (let j = 0; j < na.length; j++) {//为什么这里j<=na.length会报错?
          if (na[j] == arr[i]) {
            flag = false
          }
        }
        if (flag) {
          na[na.length] = arr[i]
        }//这个判断不能放在第二个for里面,会导致重复判断不想等,因为总有不想等的情况
        console.log(na);
      }
    }
    quchon(arr)
  </script> -->
  <!-- 作用域链=当前执行函数的作用域+[[scope]] -->
  <script>
    //==>函数定义==>[[scope]]
    // ==>函数调用==>作用域
    // ==>作用域链==>函数执行
    //(作用域链=当前执行的函数的作用域+[[scope]])
    //作用域链会在执行环境被销毁的时候自动被销毁
  </script>
  <!-- 总结:作用域链由当前的执行环境中的作用域和[[scope]]属性组成.他在函数调用时才会生成
    1.当前执行环境的作用域:函数调用时生成的
    2.[[scope]]属性:函数定义时就已经形成了,函数不调用也会有这个属性,
    16.14 -->

    <!-- 16.30 -->
</body>

</html>